# 07-row-lock

MySQL的行锁是在引擎层由各个引擎自己实现的。

## 两阶段锁

在InnoDB事务中，行锁是在需要的时候才加上，但并不是不需要了就立即释放， 而是要等到事务结束才释放。这就是两阶段锁协议。

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量 往后放。

## 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源， 就会导致这几个线程都进入无限等待的状态，称为死锁。

解决方案： 1、通过参数innodb\_lock\_wait\_timeout根据实际业务场景来设置超时时间， InnoDB引擎默认值是50s。 设置太短的话，会出现很多误伤。 2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以 继续执行。将参数innodb\_deadlock\_detect设置为on，表示开启这个逻辑（默认 是开启状态）。 正常情况采用此策略，但是它也是有额外负担的。

怎样解决热点更新导致的性能问题？ 1、如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。 2、控制并发度。 在服务端控制，基本思路是，对于相同行的更新，在进入引擎之前排队。 如果有中间件，可以考虑在中间件实现；如果能修改MySQL源码，也可以做在MySQL里面。 3、将一行改成逻辑上的多行来减少锁冲突。

