begin/start transaction命令并不是一个事务的起点，
在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），
事务才真正启动。
如果你想要马上启动一个事务，可以使用
start transaction with consistent snapshot这个命令。

InnoDB里面每个事务有一个唯一的事务ID，叫做transaction id。它是在
事务开始的时候想InnoDB的事务系统申请的，是按申请顺序严格递增的。

数据表中的一行记录，其实可能有多个版本（row），每个版本有自己的row trx_id。

![08-01-row-stat.png](08-01-row-stat.png)
图中U1、U2、U3就是undo log;V1、V2、V3并不是物理上真实存在的，而是
每次需要的时候根据当前版本和undo log计算出来的。

InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的
所有事务ID。“活跃”指的是，**启动了但是还没提交**。

数组里面事务ID的最小值记为**低水位**，当前系统里面已经创建过的事务ID的最大值加1记为
**高水位**。

这个视图数组和高水位，就组成了当前事务的**一致性试图（read-view）**。

![08-02-visibility.png](08-02-visibility.png)
对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：
1. 如果在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，
这个数据是可见的；
2. 如果在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果在黄色部分，那就包括两种情况
    - 若row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    - 若row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

一个更简单的判断方法：
1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。

事务的可重复读的能力是怎么实现的？
可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，
只能用当前读。
如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务的其他
查询都共用这个一致性视图；
* 在读提交隔离级别下，每一个语句执行前都会重新计算出一个新的视图。